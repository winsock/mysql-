Patches for any of these thoughtfully considered!  See the HACKERS file
for instructions on sending patches.

The items in the bug fix/maintenance section are the easiest to do
without breaking things, so if you're looking for a project....

Here's a meta-item that doesn't really fit into any of the categories
below: any time you must hand-roll some SQL code in your program,
consider whether it could be reduced to an API feature that would be
widely useful.  Patches or proposals of this sort are always welcome.


Final v2.0 Stuff
----------------

	o Decide what to do about subscript_iterator bugs.

	o Lockable interface is not sufficient to avoid ABI problems
	  when it is extended later.  Adding or replacing members is
	  going to shift the layout of derived classes.  To fix this,
	  change "private bool locked_" to a pointer to a Lock class,
	  which we can redefine at will.  By using a pointer, we don't
	  make the layout of the object depend on the lock mechanism
	  data details.

	o Should more classes be Lockable besides Connection and Query?


Future Features
---------------

	These changes are planned for versions after v2.0.  If you
	need one of these changes to happen on some particular
	schedule, the best way to ensure it is to start coding and
	provide a patch!


	o Transaction support.	Create a "Transaction" class, an
	  object of which you create on the stack, giving it a
	  reference to the Connection object.  Transaction object's
	  ctor calls a function on the Connection object to start a
	  transaction set, and its dtor calls another function to
	  commit the transaction.  Potential problem: it would be
	  natural to throw an exception on transaction rejection, but
	  doing this from a stack-based object's dtor can open up a lot
	  of problems.	Also, for this to work properly, the Connection
	  object has to be in a higher scope, or created on the heap.

	  Alternate approach: give Transaction a commit() member,
	  which you must call explicitly.  If you don't, the dtor will
	  roll back the transaction.  This way, committing doesn't
	  have to wait to the end of a block, so there can be code
	  following the potential exception throw point without having
	  to create an artificial block.

	o It may be possible to optimize the use of ColData in the return
	  from Row::operator[]. Currently, that operator returns
	  a temporary ColData object, which contains a std::string
	  buffer which is initialized by a const char* pointer to
	  data within the Row object.  Since the ColData object is
	  temporary, you currently must copy the data a second time to
	  store it when using Row::operator[].	If the end user just
	  wants a const char*, this double copy could be prevented.
	  See http://lists.mysql.com/plusplus/4451 for the proposal.

	o Abstract all uses of MySQL C API functions into a database
	  driver class with a generic interface.  This is a step
	  towards database-independence, without the parallel class
	  hierarchy required by the MySQL++ 1.7 design.  Also, it
	  will make it easier to make class Connection completely
	  friend-less.	Right now, the main reason it needs friends
	  is because these other classes make C API calls using its
	  private MYSQL data member.  The other reasons for it having
	  friends aren't nearly as compelling, so it wouldn't be
	  hard to justify redesigning Connection to eliminate these
	  final reasons.

	  While it would be easy to have just one global database
	  driver object, it's probably going to be necessary to have
	  one per Connection.  Consider what happens when you have one
	  program connected to two very different MySQL databases,
	  and you indirectly call C API functions that take MYSQL
	  parameters.  It's likely that those calls are supposed
	  to behave different, depending on the data in that MYSQL
	  object; for instance, different character encodings in the
	  selected databases.  So, there must somehow be a way to pass
	  the database driver's instance pointer down to all objects
	  that will need to use the driver.  A side benefit is that
	  a single program could talk to multiple different database
	  server types.  Imagine a program for importing data from
	  PostgreSQL and loading it into a MySQL table, for instance.

	o manip.cpp uses mysql_escape_string(), which doesn't take the
	  selected database's character set into account.  To do that,
	  you must use mysql_real_escape_string(), which differs
	  by taking a MYSQL instance as an additional parameter.
	  The problem is, Connection owns the relevant MYSQL instance,
	  and the manipulator functionality is implemented in global
	  functions (operator<<() and such) so they have no direct
	  access to the relevant Connection object.

	  One possible solution relies on the fact that operator<<
	  typically has an ostream parameter, from which you could
	  look up the Query object somehow, and from that get the
	  Connection object.  The tricky part is that MySQL++'s
	  operator<<'s for manipulators don't always have ostream
	  parameters.  So for this to work, manipulators would have
	  to be objects that could carry data from one operator to
	  another.  It breaks down if not all paths go through an
	  operator<< with an ostream parameter.

	  If that fails to work out, then perhaps some other method
	  will pop out of the database driver class idea.  The driver
	  object may be able to look up a suitable Connection object
	  for the manipulators.

	o Currently, all overloads for Query's execute(), store()
	  and use() methods eventually calls the const char* version,
	  which does the actual work of executing the query.  This
	  is limited to text query strings, and the implementation
	  must scan the string for length in a few places.  We'd
	  avoid these problems if the end of the chain were a
	  std::string overload, but we can't do that easily because
	  each of these functions has a version taking a SQLString
	  (a subclass of std:string) for template queries.  Either
	  add a parallel set of functions (e.g. do_execute(), or
	  execute_(), or some such) that take a single std::string
	  to replace the const char* version, or rename the template
	  query versions (e.g. to execute_tq()) to avoid the overload
	  conflict.  With that done, we can use C API functions
	  like mysql_real_query(), which can take binary data.

	o Add a configure script option to allow the new lock
	  mechanism to use platform mutexes via the Boost.Threads
	  library.

	o Consider other places true thread-awareness could be added.
	  Are there additional mechanisms besides Lockable that we
	  need to add?

	o SSQLS structures include some static elements (_table and
	  names[]), which are defined within the macro.  If you
	  put an SSQLS declaration in a header file and #include
	  that from multiple locations, you get a multiply-defined
	  symbol warning.  Some ways to separate the definition from
	  the declaration:

		  o Give the SSQLS macros another parameter, to
		    suppress static definition.

		  o Put statics in a separate macro, which the
		    user must instantiate once in a .cpp file.
		    (Similar to the way MFC message maps work.)

		  o Put statics in a sub-macro, conditionally defined,
		    which SSQLS is implemented in terms of.  Define the
			condition macro in one module within your
			program.

		  o Redesign the SSQLS mechanism entirely.  Instead of
		    defining SSQLSes by instantiating macros, you could
		    declare the structure in, say, an XML format,
		    which could be tranformed (XSLT?  Perl + a DOM
		    parser?) into code very much like in the current
		    SSQLS macros, except that it would generate
		    separate .cpp and .h files for each structure.
		    In addition to solving the static member problem,
		    it would have other advantages, like side-stepping
		    the Borland C++ macro size limit.

	o Consider whether some of the current boilerplate can be
	  made into a base class that all SSQLSes derive from.
	  This may have implications for some templates, like
	  Query::insert<T>...they might become regular member
	  functions, taking a reference to the base class.

	o MySQL++ handles automatic quoting and escaping differently
	  for cout and cerr than for Query streams.  This should
	  probably be simplified so that automatic quoting is only
	  done for Query streams.  No other stream type should be
	  treated specially.

	o Some field_list() functions use the do_nothing manipulator,
	  while others use the quote manipulator.  Need to pick one.
	  In the vast majority of cases, quoting won't be necessary,
	  so make that the default.  But, it should be possible to turn
	  it on, if needed.  If all uses of quoting are in template
	  code, this can be a #define, allowing different programs
	  built on the same system to get different quoting rules.
	  Otherwise, it will probably have to be a configure script
	  flag, which will "burn" the choice into the built binary.

	o Deprecate sql_create_basic_* ? They have less functionality
	  and they're no easier to use than sql_create and friends,
	  so why bother with them?  I suppose the code generated
	  is a bit smaller, but *really*....  Only possible saving
	  grace is if BC++ can compile them due to the macro code
	  being shorter.  They also don't have the static members,
	  which annoy some compilers.

	o User-settable floating-point comparison precisions?
	  Something like this: http://lists.mysql.com/plusplus/3984
	  As it currently stands, sql_cmp(double,double) is foolish.
	  One shouldn't do exact equality comparison on floating
	  point values.

	o Consider using MySQL C API enum constants in
	  mysql_type_info::types definition instead of hard-coded
	  values.  This could potentially break a lot of
	  infrastructure, though, so do it only with care.

	o Add time_t conversion to date and time classes.
	  Also consider other niceties, like arithmetic.
	  (See "Algorithms for Programmers" by Binstock and Rex.)
	  Then write an example showing how to use these mechanisms.

	  Alternately, find another set of date and time classes
	  (Boost?)  and extend them and the library so they can
	  replace our hand-rolled classes.

	o When you create a Connection object but don't .connect() it,
	  several of its functions can fail to work correctly.	ping(),
	  for one, because the MYSQL handle isn't initialized until
	  the connection is established.  Decide how to cope: a) init
	  the handle in all ctors; b) throw ObjectNotInitialized
	  when the library knows the call will fail; or c) just
	  return a failure code and hope the user is checking it.
	  Could be a different answer for each function.  Keep in
	  mind the consequences for database- independence here.

	o Build a forward iterator mechanism for ResUse.  Make it
	  general enough that you can use it with STL algorithms
	  like find_if().  Then make an example to demonstrate this
	  augmentation of SELECT.  Also, update usequery example
	  to use the iterator.	Tricky bit: how do we make it not
	  interfere with subclass Result's random- access iterator?


Bug Fix/Maintenance Items
-------------------------

	These items could happen in any version.


	o 64-bit integer support has been reported to work, but more
	  confirmation is wanted.

	o Have resetdb also create a table that load_file and
	  cgi_image can use.  Remove "fax"ness from these examples,
	  and encourage people to load up JPEGs or something else that
	  a browser can display, so one can easily drop cgi_image into
	  a cgi-bin directory to try it out.  Make load_image use the
	  standard command line parameters, so you can manually load up
	  some images for cgi_image to retrieve.

	o MinGW can't build a DLL for MySQL++.  It has to do with the file
	  reorganization in 1.7.20: if you move everything from row.cc to
	  a new row2.h file and include it in a few strategic locations, it
	  works.  But, this is a bogus fix.  Find the right one.

	o Template ListInsert in lib/myset.h isn't being used within the
	  library.  It could probably be used in place of SetInsert
	  in the same file, which things like type_info.h do use now,
	  but it isn't clear how one would go about doing that without
	  changing the library code.  Document it or throw it away.

	o Write an example to demonstrate compare.h features, or throw
	  the header away.  It's not being used within the library.
