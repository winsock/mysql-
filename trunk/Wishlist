Patches for any of these thoughtfully considered!  See the HACKERS file
for instructions on sending patches.

Here's a meta-item that doesn't really fit into any of the categories
below: any time you must hand-roll some SQL code in your program,
consider whether it could be reduced to an API feature that would be
widely useful.  Patches or proposals of this sort are always welcome.


v3.0 Plan, For-Sure Stuff
-------------------------
    The items in this section are those things we definitely want to
    get done in v3.0.  Most of them break the ABI, so they can't wait
    for a future version, because v4 could be years out.

    o Add conditional code to the Lockable mechanism to use platform
      mutexes if available, to implement these MySQL C API
      restrictions:

      - Only one query executing at once per connection

      - For "use" queries, Connection (and therefore Query) object must
        remain locked until last row is consumed

      - Safest to have one Connection per thread.  Rules for sharing:
        http://dev.mysql.com/doc/mysql/en/threaded-clients.html

      Need some way to call mysql_thread_init() and mysql_thread_end()
      per thread.  Also, work in some way to call mysql_thread_safe()
      automatically, perhaps the first time through the function that
      calls mysql_thread_init().  If the C API library reports that it
      is not thread-safe, report this to the caller, perhaps through
      an exception, or simply by refusing to init more than one thread.

    o Add multithreaded example to test above features and the new
      ConnectionPool class.

    o SSQLS v2:

      - Switch from C macros to some sort of DSL or XML microformat?
        Part of the MySQL++ build process would create a tool to
        convert that to C++ .cpp and .h files.  To be valuable, this
        must add type safety, better transparency of what's going on,
        better debuggability, etc.

      - If SSQLS v2 isn't a complete redesign, at least remove
        sql_create_basic_*  They're deprecated, and weak.

      - Add table creation ability to SSQLS.  It has the schema...

      - Decouple SSQLS field order MYSQL_ROW field order.  We can
        use field names to match up assigments, allowing you to have
        just one SSQLS definition, and have it cope no matter what
        subset of the table you query.  This will be slower than the
        current method, but SSQLS (and MySQL++ in general for that
        matter) isn't about speed.

      - Consider whether some of the current boilerplate can be
        made into a base class that all SSQLSes derive from.  Some
        template functions like Query::insert<T> might become regular
        member functions, taking a reference to the SSQLS base class.

    o Remove MutableColData.  It's only used within myset.h, and that
      usage is inefficient to the point of wanting replacement anyway.

    o Change ColData from a template deriving from std::string into
      a concrete class that implements the std::string interface.
      Make its internal buffer a smart pointer to MYSQL_FIELD data.
      As long as that field is alive, this prevents all the extra
      copies we see now in Row::operator[] and the population of
      SSQLSes.  If the MYSQL_FIELD is destroyed before the ColData,
      the smart pointer makes a duplicate copy of the buffer first,
      so the rest of the ColData code doesn't see any difference.
      Further info:

          http://lists.mysql.com/plusplus/4451
          http://lists.mysql.com/plusplus/4460

    o Remove const_string class.  No longer needed after above.

    o More robust fix for the Query stream base class init problem:
      http://www.boost.org/libs/utility/base_from_member.html

    o Apply Richard Forrest's iterator patch:

          http://lists.mysql.com/plusplus/5338

    o Honor only explicit use of quote and escape manipulators when
      inserting into something other than a Query stream.  Recognize
      Query streams instead of excluding only cout and cerr.

    o The quote manipulator (and presumably the others as well) don't
      work properly with char*.  See this for details:

          http://lists.mysql.com/plusplus/5617

    o Change operator[](unsigned int) in Row and the iterator classes
      to take a plain int.  This should fix the ambiguous overload
      problems, such as with row[0].  Details:

          http://lists.mysql.com/plusplus/4947
          http://lists.mysql.com/plusplus/4952
          http://lists.mysql.com/plusplus/4960
    
    o Several MySQL++ functions wrap the MySQL C API too literally:
      they indicate success by returning 0 instead of true, as most
      other wrapper functions do.

    o Apply Waba's patch allowing Null<T> fields in SSQLSes:
      
          http://lists.mysql.com/plusplus/5433

    o Change Lockable::lock() to return true if it succeeds.

    o Remove simple const char* version of Query::execute(), store(),
      and use().  The ones taking SQLString will work transparently.

    o manip.cpp uses mysql_escape_string(), which doesn't take the
      selected database's character set into account.  To do that, you
      must use mysql_real_escape_string(), which differs by taking
      a MYSQL instance as an additional parameter.  The problem
      is, Connection owns the relevant MYSQL instance, and the
      manipulator functionality is implemented in global functions
      (operator<<() and such) so they have no direct access to the
      relevant Connection object.

      The key question for all operator<<'s for manipulators
      to ask is, "which Query object am I being inserted into?"
      From there, you can look up the associated Connection object.

      In some cases, this answer to the question is easy, because
      the operator takes an ostream parameter, which can be
      dynamically cast to Query.  From there, it's just a lookup
      table problem.
      
      Other operator<<'s don't take an ostream, but they do take
      a manipulator.  Right now, manipulators are just enum values,
      but they could in fact be classes.  Classes can carry data,
      so there may be a way to "bind" them to the appropriate
      Connection object.  If not, then perhaps some other method
      will pop out of the database driver class idea.  The driver
      object may be able to look up a suitable Connection object
      for the manipulators.

    o Some field_list() functions use the do_nothing manipulator,
      while others use the quote manipulator.  Need to pick one.
      In the vast majority of cases, quoting won't be necessary, so
      make that the default.  But, it should be possible to turn it
      on, if needed.  If all uses of quoting are in template code,
      this can be a #define, allowing different programs built on
      the same system to get different quoting rules.  Otherwise,
      it will probably have to be a configure script flag, which will
      "burn" the choice into the built binary.

    o Add user-settable floating-point comparison precisions:

        http://lists.mysql.com/plusplus/3984


v3.0 "Maybe" Stuff
------------------
    This is stuff that would be nice to have, but it wouldn't be a
    good idea to bet on seeing it in v3.0.  If you really want some
    of this, best to just get coding and provide a patch!

    o Replace Query::preview() with operator<<, for easy debugging?
      If one really wants a std::string, they can still call str(),
      which is currently the same thing.

    o Does Query::reset() provide any benefit?  Why doesn't it reset
      automatically for all queries?  I guess if you were to re-run
      the same query multiple times, but who does that?

    o Define operator<< for Fields, Row, ResUse, etc.  In other
      words, there should be a way to get a user-readable version
      of received data without a lot of code.  Perhaps use a CSV
      output format, or a mysql(1) one (ASCII grid).

    o Extend the manipulators to handle nullable versions of the
      types we already support.  Should just be a matter of duplicating
      the existing type-specific manipulator functions, and wrapping
      the types in Null<>.

    o Add syntactic sugar to the Date and Time classes.  A way to
      represent SQL's NOW() function would be especially helpful.

    o Abstract all uses of MySQL C API functions into a database
      driver class with a generic interface.  This is a step towards
      database-independence, without the parallel class hierarchy
      required by the MySQL++ 1.7 design.  Also, it will make it easier
      to make class Connection completely friend-less.  Right now,
      the main reason it needs friends is because these other classes
      make C API calls using its private MYSQL data member.  The other
      reasons for it having friends aren't nearly as compelling,
      so it wouldn't be hard to justify redesigning Connection to
      eliminate these final reasons.

      While it would be easy to have just one global database
      driver object, it's probably going to be necessary to have
      one per Connection.  Consider what happens when you have one
      program connected to two very different MySQL databases, and
      you indirectly call C API functions that take MYSQL parameters.
      It's likely that those calls are supposed to behave different,
      depending on the data in that MYSQL object; for instance,
      different character encodings in the selected databases.  So,
      there must somehow be a way to pass the database driver's
      instance pointer down to all objects that will need to use
      the driver.  A side benefit is that a single program could talk
      to multiple different database server types.  Imagine a program
      for importing data from PostgreSQL and loading it into a MySQL
      table, for instance.

    o Chris Frey's packarray class

    o Refactor option mechanism in Connection class into its own
      class.  There are a whole lot of functions, structs and enums
      related to this.

    o Figure out some way to name debug DLL and library under VC++
      differently (trailing 'd'?) to prevent some problems due
      to mixing debug and release programs and MySQL++ DLLs.
      This appears to require changes to Bakefile, or some sort of
      post-build hackery.

    o Create adaptors for std::bitset, for storing binary data in a
      MySQL table.  Make two options available, one for storing the
      return from bitset::to_ulong() in an UNSIGNED INTEGER column,
      and another for storing a larger set of bits in a more flexible
      way, perhaps as a BLOB.

    o Row object currently depends on the associated ResUse object
      to stick around through all calls to .at(), because it needs
      the list of field types in the result set to construct ColData
      objects.  This means it's not possible to store the result of
      several queries before accessing the data.  Currently, this
      is just a documented limitation, but it would be nice if there
      were a clean way to avoid this.  Obviously you could just copy
      the type list when constructing the Row object, but that seems
      pointlessly inefficient.  Some sort of ownership hand-off if
      the ResUse object goes away or gets reused first?

    o Consider using MySQL C API enum constants in
      mysql_type_info::types definition instead of hard-coded values.
      This could potentially break a lot of infrastructure, though,
      so do it only with care.

    o Some sort of support for prepared statements.

