Patches for any of these thoughtfully considered!  See the HACKERS file
for instructions on sending patches.

Here's a meta-item that doesn't really fit into any of the categories
below: any time you must hand-roll some SQL code in your program,
consider whether it could be reduced to an API feature that would be
widely useful.  Patches or proposals of this sort are always welcome.


v3.0 Plan, For-Sure Stuff
-------------------------
    The items in this section are those things we definitely want to
    get done in v3.0.  Most of them break the ABI, so they can't wait
    for a future version, because v4 could be years out.

    o The manipulator changes sometime during 2.3 broke the column
      formatting of the examples that dump tables.  A setw(x) call
      results in x spaces, not x - strlen(whatevercamebefore).

    o Derive RefCountedPointer from SafeBool<T>, and try to drop
      operator!().

    o Classes Connection, Query, String, Result and Row all have
      operator bool() as well.  Use "safe bool" here too, as needed.

    o Apply Jonathan Wakely's patch to RefCountedPointer.

    o Atomic inc/dec of reference counts in RefCounted*?

    o Add Connection::thread_start() and thread_end(), wrapping C API.
      Mention in userman threads chapter that these only need to
      be called when doing something tricky or linking statically
      on Windows.  Automatic otherwise.

    o Add Connection::thread_safe(), wrapping mysql_thread_safe() plus
      maybe also a #defined value set at MySQL++ library build time
      if thread awareness is enabled.

    o Add Connection::thread_id()

    o Add multithreaded examples to test above features and the new
      ConnectionPool class?  They'd have to be platform-specific...
      If we decide not to do it, pull reference to the example from
      section 7.2 of userman.

    o Rework elment access in subscript_iterator derivatives:

      - Change data management to work like String's new reference-
        counted buffer mechanism where possible to avoid copying
        large data blocks when returning things by value.

      - Change operator[] from value to reference semantics every
        place this is possible.

      - If we can get reference semantics everywhere, we can add
        operator->() to subscript_iterator.  It can't work with
        value semantics.

    o More robust fix for the Query stream base class init problem:
      http://www.boost.org/libs/utility/base_from_member.html

    o Refactor option mechanism in Connection, in several steps:
    
      - Create new optionlist module, initially empty.  Each step below
        moves code and declarations into this module.

      - Replace OptionInfo struct, OptionArgType enum, and Option
        enum with a class hierarchy: totally abstract Option interface
        at the top level, BoolOption, IntOption, and StringOption at
        second level.  Each second-level class is subclassed once
        for each of the options currently defined in Options enum.
        This binds the legal option argument types with the options
        themselves, instead of requiring a lookup table to match enum
        values to types.  OptionList then becomes a list of Option*.

      - Create OptionSetter class as a base class for Connection.  It
        contains the actual option list object, provides the public
        interface to that list, and possibly a callback mechanism for
        Connection to override to give the Option objects the access
        they need to actually implement the option setting operation.
        (They need access to Connection::mysql_, for example.)

      - Add new Option subclass SSLOption, and reimplement
        Connection::enable_ssl() in terms of it.  The success of this
        will prove the value of an extensible option type system.

    o Query::preview(void) should not crash when query string is
      a parsed template.  It's probably running off the end of the
      default argument list, or trying to dereference a null pointer.

    o Is MYSQLPP_QUERY_THISPTR still needed with VC++2003?  The recent
      manipulator changes and the removal of all operator<<(Query&,
      const T&) may make it unnecessary.


v3.0 "Maybe" Stuff
------------------
    This is stuff that would be nice to have, but it wouldn't be a
    good idea to bet on seeing it in v3.0.  If you really want some
    of this, best to just get coding and provide a patch!

    o Replace Query::preview() with operator<<, for easy debugging?
      If one really wants a std::string, they can still call str(),
      which is currently the same thing.

    o Define operator<< for Fields, Row, ResUse, etc.  In other
      words, there should be a way to get a user-readable version
      of received data without a lot of code.  Perhaps use a CSV
      output format, or a mysql(1) one (ASCII grid).

    o Add syntactic sugar to the Date and Time classes.  A way to
      represent SQL's NOW() function would be especially helpful.

    o Figure out some way to name debug DLL and library under VC++
      differently (trailing 'd'?) to prevent some problems due
      to mixing debug and release programs and MySQL++ DLLs.
      This appears to require changes to Bakefile, or some sort of
      post-build hackery.

    o Try using MySQL C API enum constants in mysql_type_info::types
      instead of hard-coded values.


v3.1 Tentative Plan
-------------------
    o SSQLS v2:

      - Switch from C macros to a DSL that is translated to .cpp and
        .h files by a tool built along with MySQL++ library.  Design:

        http://lists.mysql.com/plusplus/6929

      - Add features to that tool to write SSQLSv2 declaration files
        from existing schemas extracted from CREATE TABLE statements,
        from running databases, and from C++ files containing old
        SSQLS v1 declarations.

      - Add table creation ability to SSQLS.  It has the schema...

      - Decouple SSQLS field order from MYSQL_ROW field order.  We can
        use field names to match up assigments, allowing you to have
        just one SSQLS definition, and have it cope no matter what
        subset of the table you query.  This will be slower than the
        current method, but SSQLS (and MySQL++ in general for that
        matter) isn't about speed.

      - Consider whether some of the current boilerplate can be
        made into a base class that all SSQLSes derive from.  Some
        template functions like Query::insert<T> might become regular
        member functions, taking a reference to the SSQLS base class.

    o Chris Frey's packarray class

    o Create adaptors for std::bitset, for storing binary data in a
      MySQL table.  Make two options available, one for storing the
      return from bitset::to_ulong() in an UNSIGNED INTEGER column,
      and another for storing a larger set of bits in a more flexible
      way, perhaps as a BLOB.

    o field_list should use backticks to quote its items to handle
      spaces and other special characters.  Probably also remove all
      the manipulator stuff associated with these: no reason to make
      it user-settable, as there's only one right way to do it.  See:

         http://dev.mysql.com/doc/refman/5.0/en/identifiers.html

    o Define custom template for sql_double et al., with the comparison
      precision being the parameter:

        http://lists.mysql.com/plusplus/3984

    o Either add quote_force and similar manipulators, or remove the
      'r' and 'R' modifiers in template queries.  As it stands, you
      can't force Query streams to quote or escape something if MySQL++
      knows it's never required in SQL, but these modifiers let you
      do it for parameters in template queries.  Pick one behavior,
      and change the footnote about this from the quoting and escaping
      section of the userman.



v4.0 or Later
-------------
    o Abstract all uses of MySQL C API functions into a database
      driver class with a generic interface.  This is a step towards
      database-independence, without the parallel class hierarchy
      required by the MySQL++ 1.7 design.

      A bonus is that it'll let us remove Connection's last friend,
      Query, which only needs to be a friend to make C API calls
      using Connection::mysql_.

      Abstract base class DBDriver declares the generic interface;
      it's subclassed for every database server type we support.
      Connection object creates leaf class, passes it generically
      as a DBDriver* to Query, which passes it to Result.  At the
      moment, that's all the classes that access the C API themselves.
      Everything else goes through either Query or Connection.

    o Some sort of support for prepared statements.  Can we hijack
      the template query mechanism?
