<?xml version="1.0" encoding='UTF-8'?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook V4.3//EN"
    "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<sect1 id="configuration">
  <title>Configuring MySQL++</title>

  <para>The default configuration of MySQL++ is suitable for most
  purposes, but there are a few things you can change to make it meet
  special needs.</para>

  <sect2 id="mysql-loc">
    <title>The Location of the MySQL Development Files</title>

    <para>MySQL++ is built on top of the MySQL C API. It relies on
    this low-level library for all communication with the database
    server. Consequently, the build process for MySQL++ may fail if
    it can&rsquo;t find the C API headers and library.</para>

    <para>On platforms that use Autoconf<footnote><para>Linux,
    Solaris, the BSDs, Mac OS X command line (as opposed to the
    Xcode IDE), Cygwin... Basically, Unix or anything that works
    like it.</para></footnote>, the <filename>configure</filename>
    script can usually figure out the location of the C API
    development files by itself. It simply tries a bunch of common
    installation locations until it finds one that works. If
    your MySQL server was installed in a nonstandard location,
    you will have to tell the <filename>configure</filename>
    script where these files are with some combination
    of the <computeroutput>--with-mysql</computeroutput>,
    <computeroutput>--with-mysql-include</computeroutput>, and
    <computeroutput>--with-mysql-lib</computeroutput> flags. See
    <filename>README-Unix.txt</filename> for details.</para>

    <para>No other platform allows this sort of auto-discovery,
    so the build files for these platforms simply hard-code the
    default installation location for the current Generally
    Available version of MySQL. For example, the Visual C++
    project files currently assume MySQL is in <filename>c:\Program
    Files\MySQL\MySQL Server 5.0</filename>. If you&rsquo;re using
    some other release of MySQL or you installed it in a nonstandard
    location, you will have to modify the build files.  How you do
    this, exactly, varies based on platform and what tools you have
    on hand. See <filename>README-Visual-C++.txt</filename>,
    <filename>README-MinGW.txt</filename>, or
    <filename>README-Mac-OS-X.txt</filename>, as appropriate.</para>
  </sect2>


  <sect2 id="max-fields">
    <title>The Maximum Number of Fields Allowed</title>

    <para>MySQL++ offers two ways to automatically build SQL
    queries at run time: <xref linkend="tquery"/> and <link
    linkend="ssqls">SSQLS</link>. There&rsquo;s a limit on the number
    of fields these mechanisms support, primarily to avoid exceeding
    limits in some compilers. The default for each is 25 fields in the
    source distribution.<footnote><para>If you&rsquo;re using a binary
    MySQL++ package, its maintainer may have increased these field
    counts so the resulting headers more closely approach the size
    limit of the compiler the package was built with. In that case,
    you can look at the top of each generated header file to find
    out how many fields each supports.</para></footnote> This is high
    enough to work with most good database designs.<footnote><para>If
    your database design has a table with more than 25 columns,
    you might consider refactoring it. It&rsquo;s a fair indicator
    the design commits some sin a DBA would castigate as improper
    normalization.</para></footnote></para>

    <para>Perhaps your database design does need more than 25
    SSQLS fields or template query parameters. You can raise these
    limits by re-generating the <filename>lib/ssqls.h</filename>
    and/or <filename>lib/querydef.h</filename> headers. These
    files are generated by Perl scripts of the same name,
    except with a <filename>pl</filename> extension.</para>

    <para>The default <filename>querydef.h</filename> is small and
    its size only increases linearly with respect to field count. Even
    with an insanely large table, it shouldn&rsquo;t be a problem to
    increase this file&rsquo;s field limit.</para>

    <para>The reason we worry about large field counts exceeding
    compiler limits is all down to <filename>ssqls.h</filename>. It
    is already a rather large file with the default of 25
    fields, at over 1&nbsp;MB. Worse, its size goes up
    <emphasis>quadratically</emphasis> as a function of
    field count.  Doubling the default nearly quadruples
    the file size!<footnote><para>The amateur mathematician
    reading this may be wondering, why doesn&rsquo;t doubling
    the field count exactly quadruple the file size, if
    it&rsquo;s a quadratic relationship? It&rsquo;s because
    the equation relating them has a few lower-order terms:
    <phrase role="math">N<subscript>lines</subscript> =
    18.5f<superscript>2</superscript> + 454.5f + 196.4</phrase>,
    where <varname>f</varname> is the field count.</para></footnote>
    Thus the need for a field limit: many compilers have limits on the
    size of preprocessor macros. It may be that the compiler you use
    is able to cope with much larger macros than we like to generate
    by default.</para>

    <para>If you&rsquo;re building MySQL++ from source on
    a platform that uses Autoconf, the easiest way to change
    these limits is at configuration time:</para>
    
    <screen>
./configure --with-field-limit=50</screen>
    
    <para>That causes the configuration script to pass the
    <command>-f</command> flag to the two Perl scripts named above,
    overriding the default of 25 fields. Obviously you need a
    Perl interpreter on the system for this to work, but Perl is
    usually installed by default on systems MySQL++ supports via
    Autoconf.</para>

    <para>On all other platforms, you&rsquo;ll have to give the
    <command>-f</command> flag to these scripts yourself. This
    may require installing Perl and putting it in the command
    path first. Having done that, you can do something like this to
    raise the limits:</para>

    <screen>
cd lib
perl ssqls.pl -f 50
perl querydef.pl -f 50</screen>

    <para>Note the need to run these commands within the
    <filename>lib</filename> subdirectory of the MySQL++ source
    tree. (This is done for you automatically on systems where you
    are able to use the Autoconf method.)</para>
  </sect2>


  <sect2 id="buried-headers">
    <title>Buried MySQL C API Headers</title>

    <para>It&rsquo;s common these days on Unixy systems to install
    the MySQL C API headers in a <filename>mysql</filename> directory
    under some common <filename>include</filename> directory. If the
    C API headers are in <filename>/usr/include/mysql</filename>, we
    say they are &ldquo;buried&rdquo; underneath the system&rsquo;s
    main include directory, <filename>/usr/include</filename>. Since
    the MySQL++ headers depend on these C API headers, it can be
    useful for MySQL++ to know this fact.</para>

    <para>When MySQL++ includes one of the C API headers, it normally
    does so in the obvious way:</para>

    <programlisting>
#include &lt;mysql.h&gt;
</programlisting>

    <para>But, if you define the
    <varname>MYSQLPP_MYSQL_HEADERS_BURIED</varname> macro, it switches
    to this style:</para>

    <programlisting>
#include &lt;mysql/mysql.h&gt;
</programlisting>

    <para>In common situations like the
    <filename>/usr/include/mysql</filename> one, this simplifies the
    include path options you pass to your compiler.</para>
  </sect2>


  <sect2 id="c99">
    <title>Building MySQL++ on Systems Without Complete C99
    Support</title>

    <para>MySQL++ uses the <ulink
    url="http://en.wikipedia.org/wiki/C_(programming_language)#C99">C99</ulink>
    header <filename>stdint.h</filename> for portable fixed-size
    integer typedefs where possible. The C99 extensions aren&rsquo;t
    yet officially part of the C++ Standard, so there are still
    some C++ compilers that don&rsquo;t offer this header. MySQL++
    works around the lack of this header where it knows it needs
    to, but your platform might not be recognized, causing
    the build to break. If this happens, you can define the
    <varname>MYSQLPP_NO_STDINT_H</varname> macro to make MySQL++
    use its best guess for suitable integer types instead of relying
    on <filename>stdint.h</filename>.</para>

    <para>MySQL++ also uses C99&rsquo;s <type>long long</type>
    data type where available. MySQL++ has workarounds for platforms
    where this is known not to be available, but if you get errors in
    <filename>common.h</filename> about this type, you can define the
    macro <varname>MYSQLPP_NO_LONG_LONGS</varname> to make MySQL++
    fall back to portable constructs.</para>
  </sect2>
</sect1>
