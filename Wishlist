Patches for any of these thoughtfully considered!  See the HACKERS file
for instructions on sending patches.

Here's a meta-item that doesn't really fit into any of the categories
below: any time you must hand-roll some SQL code in your program,
consider whether it could be reduced to an API feature that would be
widely useful.  Patches or proposals of this sort are always welcome.


v3.0 Plan
---------
    The items in this section are those things we currently expect
    to get done for v3.0.  Most of them break the ABI, so they can't
    wait for a future version, because v4 could be years out.

    o Create examples/vstudio/threads to test new thread-related
      features.  Only VC++ since every other platform has the
      possibility of building without thread support.  Then work
      it into userman's threads chapter, which already has a stub
      for this.

    o Rework element access in subscript_iterator derivatives:

      - Change data management to work like String's new reference-
        counted buffer mechanism where possible to avoid copying
        large data blocks when returning things by value.

      - Change operator[] from value to reference semantics every
        place this is possible.

      - If we can get reference semantics everywhere, we can add
        operator->() to subscript_iterator.  It can't work with
        value semantics.

    o More robust fix for the Query stream base class init problem:
      http://www.boost.org/libs/utility/base_from_member.html

    o Refactor option mechanism in Connection, in several steps:
    
      - Create new optionlist module, initially empty.  Each step below
        moves code and declarations into this module.

      - Replace OptionInfo struct, OptionArgType enum, and Option
        enum with a class hierarchy: totally abstract Option interface
        at the top level, BoolOption, IntOption, and StringOption at
        second level.  Each second-level class is subclassed once
        for each of the options currently defined in Options enum.
        This binds the legal option argument types with the options
        themselves, instead of requiring a lookup table to match enum
        values to types.  OptionList then becomes a list of Option*.

      - Create OptionSetter class as a base class for Connection.  It
        contains the actual option list object, provides the public
        interface to that list, and possibly a callback mechanism for
        Connection to override to give the Option objects the access
        they need to actually implement the option setting operation.
        (They need access to Connection::mysql_, for example.)

      - Add new Option subclass SSLOption, and reimplement
        Connection::enable_ssl() in terms of it.  The success of this
        will prove the value of an extensible option type system.

    o Query::preview(void) should not crash when query string is
      a parsed template.  It's probably running off the end of the
      default argument list, or trying to dereference a null pointer.

    o If Bakefile 0.2.3 (guessing) comes out before we release, change
      all the msvs2005prj references in mysql++.bkl, Bakefiles.bkgen
      and rebake.bat to msvs2003prj and remove the section on doing
      this by hand from README.vc.  If not, we might need to update
      some of the FAQ items on the MySQL++ home page.

    o Is MYSQLPP_QUERY_THISPTR still needed with VC++2003?  The recent
      manipulator changes and the removal of all operator<<(Query&,
      const T&) may make it unnecessary.

    o Document that Query::storein() now works with raw Row objects.
      It used to fail because of the Result/Row lifetime issue,
      which didn't apply to SSQLS because of the data copy.

    o Create an SSQLS base class containing all of the common
      boilerplate, which leaf SSQLSes derive from.  This should in turn
      allow template functions like Query::insert<T> to become regular
      member functions, taking a reference to the SSQLS base class.

    o Remove "basic" variants of SSQLS creation macros, and remove
      userman sections covering them.

    o Either add quote_force and similar manipulators, or remove the
      'r' and 'R' modifiers in template queries.  As it stands, you
      can't force Query streams to quote or escape something if MySQL++
      knows it's never required in SQL, but these modifiers let you
      do it for parameters in template queries.  Pick one behavior,
      and change the footnote about this from the quoting and escaping
      section of the userman.

    o Fold Query::preview(void) into str(), and rename all of the
      multiple-argument forms of preview() to str().

    o A set of Query::str() overloads that take an ostream for the
      first parameter would be useful.

    o Add operator<< for Query, syntactic sugar for str(ostream&).


v3.0 "Maybe" Stuff
------------------
    This is stuff that would be nice to have, but it wouldn't be a
    good idea to bet on seeing it in v3.0.  If you really want some
    of this, best to just get coding and provide a patch!

    o Make RefCountedPointer::swap() private?  Could be a good reason
      for it to be public, but no one's given such a reason yet.

    o Atomic inc/dec of reference counts in RefCounted*?  To justify
      it, one has to justify using two threads to process data,
      such as one thread doing queries, and another processing the
      results, resulting in a possibility of the two threads trying to
      do things in such an order as to risk a race on the refcount.
      Without such a justification, it means adding complexity and
      slowing the individual threads down for no counterbalancing
      gain in multithread performance.

    o Add syntactic sugar to the Date and Time classes.  A way to
      represent SQL's NOW() function would be especially helpful.

    o Figure out some way to name debug DLL and library under VC++
      differently (trailing 'd'?) to prevent some problems due
      to mixing debug and release programs and MySQL++ DLLs.
      This appears to require changes to Bakefile, or some sort of
      post-build hackery.

    o Try using MySQL C API enum constants in mysql_type_info::types
      instead of hard-coded values.


v3.1 Tentative Plan
-------------------
    o SSQLS v2:

      - Switch from C macros to a DSL that is translated to .cpp and
        .h files by a tool built along with MySQL++ library.  Design:

        http://lists.mysql.com/plusplus/6929

      - Add features to that tool to write SSQLSv2 declaration files
        from existing schemas extracted from CREATE TABLE statements,
        from running databases, and from C++ files containing old
        SSQLS v1 declarations.

      - Add table creation ability to SSQLS.  It has the schema...

      - Decouple SSQLS field order from MYSQL_ROW field order.  We can
        use field names to match up assigments, allowing you to have
        just one SSQLS definition, and have it cope no matter what
        subset of the table you query.  This will be slower than the
        current method, but SSQLS (and MySQL++ in general for that
        matter) isn't about speed.

    o Chris Frey's packarray class

    o Create adaptors for std::bitset, for storing binary data in a
      MySQL table.  Make two options available, one for storing the
      return from bitset::to_ulong() in an UNSIGNED INTEGER column,
      and another for storing a larger set of bits in a more flexible
      way, perhaps as a BLOB.

    o field_list should use backticks to quote its items to handle
      spaces and other special characters.  Probably also remove all
      the manipulator stuff associated with these: no reason to make
      it user-settable, as there's only one right way to do it.  See:

         http://dev.mysql.com/doc/refman/5.0/en/identifiers.html

    o Define custom template for sql_double et al., with the comparison
      precision being the parameter:

        http://lists.mysql.com/plusplus/3984

    o Define operator<< for Fields, Row, ResUse, etc.  In other
      words, there should be a way to get a user-readable version of
      received data without a lot of code.  CSV format by default, and
      mysql(1)-like ASCII grid optionally, perhaps with a manipulator?
      There is grid code in examples/multiquery.cpp which we can use
      and then make multiquery.cpp a demonstration platform for it.
      Maybe dbinfo and fieldinf, too?



v4.0 or Later
-------------
    o Abstract all uses of MySQL C API functions into a database
      driver class with a generic interface.  This is a step towards
      database-independence, without the parallel class hierarchy
      required by the MySQL++ 1.7 design.

      A bonus is that it'll let us remove Connection's last friend,
      Query, which only needs to be a friend to make C API calls
      using Connection::mysql_.

      Abstract base class DBDriver declares the generic interface;
      it's subclassed for every database server type we support.
      Connection object creates leaf class, passes it generically
      as a DBDriver* to Query, which passes it to Result.  At the
      moment, that's all the classes that access the C API themselves.
      Everything else goes through either Query or Connection.

    o Some sort of support for prepared statements.  Can we hijack
      the template query mechanism?
