Patches for any of these thoughtfully considered!  See the HACKERS file
for instructions on sending patches.

The items in the bug fix/maintenance section are the easiest to do
without breaking things, so if you're looking for a project....

Here's a meta-item that doesn't really fit into any of the categories
below: any time you must hand-roll some SQL code in your program,
consider whether it could be reduced to an API feature that would be
widely useful.  Patches or proposals of this sort are always welcome.


v2.2 Plan
---------

	This plan is not set in stone.	These are simply the features
	we want to try and tackle for the v2.2 release.

	Items in this plan may slip to a future release.  This
	typically happens when the proper solution is unclear,
	so the best way to prevent this is to get on the mailing
	list and help discuss it.  Or even better, provide a patch;
	we rarely reject working code outright.

	Items from the following sections may make it in, but if
	you don't help make that happen, this will just be on the
	whim of one of MySQL++'s developers.  Don't forget that it's
	possible to subclass yourself from the "MySQL++'s developers"
	base class.


	o Name debug DLL and library under VC++ differently (trailing
	  'd'?) to prevent some problems due to mixing debug and
	  release programs and MySQL++ DLLs.

	o Hoist all inline function definitions up into the class
	  definition, to avoid linkage warning problems with MinGW.
	  See http://lists.mysql.com/plusplus/5806 for details.
	  While doing that, consider whether the function should be
	  inline at all.  This can cause versioning problems with DLLs
	  and shared libraries, with the program using inlines from one
	  version of the library and imported functions from another.

	o Add DLL declspecs to class level, too, to allow it to link
	  properly under MinGW with certain versions of the tools.
	  Same thread as above.

	o Currently, all overloads for Query's execute(), store()
	  and use() methods eventually call the const char*
	  version, which does the actual work of executing the query.
	  This rules out query strings with embedded nulls, as you're
	  likely to get with BLOB columns.  Also, it means MySQL++
	  must scan the string for length in a few places.  The C API
	  isn't limited in this way if you use mysql_real_query(),
	  but you need an accurate length value to call it.

	  Fix by co-opting the first template query version of each
	  of these functions, as it takes a single SQLString, which
	  contains a length and doesn't care about nulls.  Also add
	  an overload taking a const char* and a length parameter,
	  for cases where the user doesn't want to convert their
	  data to a std::string variant.  Make the latter the actual
	  terminus of the call chain, as it's cheaper to convert from
	  SQLString to const char* than the reverse.

	o ColData doesn't cope with nulls very well, such as storing
	  BLOB column data.  This manifests in things like Row::at()
	  returning truncated data, because somewhere along the line
	  a ColData object was created using only a char*; we need to
	  be able to use a length as well.  Update examples/cgi_image
	  to use this new mechanism.

	o A BLOB field containing a null will be truncated when using
	  SSQLS with a std::string member.  This is probably related
	  to the previous item.

	o Have resetdb create a second table containing a BLOB column
	  that load_file and cgi_image can use.  
	  
	  Rework load_image to take the standard command line
	  parameters, and load a JPEG or something into the BLOB table.
	  Include a suitable JPEG with the distribution.  (A cheesy
	  Photoshopped "MySQL++ Rocks!" thing should suffice.)

	  Rework cgi_image so that you can drop it into a cgi-image
	  directory and immediately use it to query the database and
	  return the image data in CGI format.

	o Add a few features to date and time classes:

	  - time_t conversion.

	  - It may be possible to get some nice syntactic sugar,
	    such as a way to call SQL functions like NOW() when
	    inserting certain Date/Time objects into a Query stream.

	  - Arithmetic features?  (See "Practical Algorithms for
	    Programmers" by Binstock and Rex.)

	  Don't forget to write an example showing how to use these
	  new mechanisms.


v2.3 Plan
---------

	This plan is even more nebulous than the v2.2 plan.  The only
	thing that puts a feature on this list and not on the v3.0
	list is that they can be done without breaking the ABI,
	which forces a feature to v3.0.  Items on this list could
	still easily slip to v3.0.  There might not even _be_ a v2.3...

	o Conditionally allow the Lockable mechanism to use the
	  Boost.Threads library.  If MYSQLPP_BOOST_THREADS is defined,
	  #include the proper header and use Boost's mutexes.  Add a
	  configure script option that defines this macro and adds
	  any needed libraries to the <sys-lib> tags.

	  Mechanism must reflect these MySQL C API restrictions:

	  - Only one query executing at once per connection

	  - For "use" queries, Connection (and therefore Query) object must
	    remain locked until last row is consumed

	  - Safest to have one Connection per thread.  Rules for sharing:
	    http://dev.mysql.com/doc/mysql/en/threaded-clients.html

	  Need some way to call mysql_thread_init() and
	  mysql_thread_end() per thread.  Also, work in some way to
	  call mysql_thread_safe() automatically, perhaps the first
	  time through the function that calls mysql_thread_init().
	  If the C API library reports that it is not thread-safe,
	  report this to the caller, perhaps through an exception,
	  or simply by refusing to init more than one thread.

	o Build a forward iterator mechanism for ResUse.  Make it
	  general enough that you can use it with STL algorithms
	  like find_if().  Then make an example to demonstrate this
	  augmentation of SELECT.  Also, update usequery example
	  to use the iterator.	Tricky bit: how do we make it not
	  interfere with subclass Result's random-access iterator?

	o It may be possible to optimize the use of ColData in
	  the return from Row::operator[].  Currently, that operator
	  returns a temporary ColData object, which contains a
	  std::string buffer which is initialized by a const char*
	  pointer to data within the Row object.  Since the ColData
	  object is temporary, you currently must copy the data a
	  second time to store it when using Row::operator[].  If the
	  end user just wants a const char*, this double copy could
	  be prevented.  See http://lists.mysql.com/plusplus/4451
	  for the proposal.

	o Add Chris Frey's packarray class?


v3.0 Plan
---------

	Version 3.0 is primarily for those changes that will break
	the ABI.  (i.e. removing functions, changing function
	signatures, etc.)  This plan is very tenuous.  Some of this
	could slip to v4.0.

	o Apply Richard Forrest's iterator patch.

	o The quote manipulator (and presumably the others as well) don't
	  work properly with char*.  See this for details:

	      http://lists.mysql.com/plusplus/5617

	o Change the unsigned int overloads for operator[] on
	  const_subscript_iterator and its subclasses from unsigned
	  int to a plain int.  This should fix the ambiguous overload
	  problems, such as with row[0].

	  See the following threads for reference:
	      http://lists.mysql.com/plusplus/4947
	      http://lists.mysql.com/plusplus/4952
	      http://lists.mysql.com/plusplus/4960
	
	o Several MySQL++ functions wrap the MySQL C API too literally:
	  they indicate success by returning 0 instead of true,
	  as most other wrapper functions do.

	o Apply Waba's patch allowing Null<T> fields in SSQLSes:
	  http://lists.mysql.com/plusplus/5433

	o Deprecate sql_create_basic_*  They have less functionality
	  and they're no easier to use than sql_create and friends.

	o Consider whether some of the current boilerplate can be
	  made into a base class that all SSQLSes derive from.	Some
	  template functions like Query::insert<T> might become regular
	  member functions, taking a reference to the SSQLS base class.

	o Abstract all uses of MySQL C API functions into a database
	  driver class with a generic interface.  This is a step
	  towards database-independence, without the parallel class
	  hierarchy required by the MySQL++ 1.7 design.  Also, it
	  will make it easier to make class Connection completely
	  friend-less.	Right now, the main reason it needs friends
	  is because these other classes make C API calls using its
	  private MYSQL data member.  The other reasons for it having
	  friends aren't nearly as compelling, so it wouldn't be
	  hard to justify redesigning Connection to eliminate these
	  final reasons.

	  While it would be easy to have just one global database
	  driver object, it's probably going to be necessary to have
	  one per Connection.  Consider what happens when you have one
	  program connected to two very different MySQL databases,
	  and you indirectly call C API functions that take MYSQL
	  parameters.  It's likely that those calls are supposed
	  to behave different, depending on the data in that MYSQL
	  object; for instance, different character encodings in the
	  selected databases.  So, there must somehow be a way to pass
	  the database driver's instance pointer down to all objects
	  that will need to use the driver.  A side benefit is that
	  a single program could talk to multiple different database
	  server types.  Imagine a program for importing data from
	  PostgreSQL and loading it into a MySQL table, for instance.



Future Features
---------------

	These changes are not assigned to any particular version.
	They could happen at any time.	If you want one to appear at
	some definite date, get coding and provide a patch!

	o Drop recursive make.	This will make parallel building work
	  correctly, and it makes for a single VC++ project file.
	  It'll make the "don't build examples" case a little trickier,
	  but that's not a deal-breaker.

	o Create adaptors for std::bitset, for storing binary data in a
	  MySQL table.	Make two options available, one for storing
	  the return from bitset::to_ulong() in an UNSIGNED INTEGER
	  column, and another for storing a larger set of bits in a
	  more flexible way, perhaps as a BLOB.

	o Row object currently depends on the associated ResUse object
	  to stick around through all calls to .at(), because it needs
	  the list of field types in the result set to construct
	  ColData objects.  This means it's not possible to store
	  the result of several queries before accessing the data.
	  Currently, this is just a documented limitation, but it
	  would be nice if there were a clean way to avoid this.
	  Obviously you could just copy the type list when constructing
	  the Row object, but that seems pointlessly inefficient.

	o Define operator<< for Fields, Row, ResUse, etc.  In other
	  words, there should be a way to get a user-readable version
	  of received data without a lot of code.  Perhaps use a CSV
	  output format, or a mysql(1) one (ASCII grid).

	o manip.cpp uses mysql_escape_string(), which doesn't take the
	  selected database's character set into account.  To do that,
	  you must use mysql_real_escape_string(), which differs
	  by taking a MYSQL instance as an additional parameter.
	  The problem is, Connection owns the relevant MYSQL instance,
	  and the manipulator functionality is implemented in global
	  functions (operator<<() and such) so they have no direct
	  access to the relevant Connection object.

	  The key question for all operator<<'s for manipulators
	  to ask is, "which Query object am I being inserted into?"
	  From there, you can look up the associated Connection object.

	  In some cases, this answer to the question is easy, because
	  the operator takes an ostream parameter, which can be
	  dynamically cast to Query.  From there, it's just a lookup
	  table problem.
	  
	  Other operator<<'s don't take an ostream, but they do take
	  a manipulator.  Right now, manipulators are just enum values,
	  but they could in fact be classes.  Classes can carry data,
	  so there may be a way to "bind" them to the appropriate
	  Connection object.  If not, then perhaps some other method
	  will pop out of the database driver class idea.  The driver
	  object may be able to look up a suitable Connection object
	  for the manipulators.

	o MySQL++ handles automatic quoting and escaping differently
	  for cout and cerr than for Query streams.  This should
	  probably be simplified so that automatic quoting is only
	  done for Query streams.  No other stream type should be
	  treated specially.

	o Some field_list() functions use the do_nothing manipulator,
	  while others use the quote manipulator.  Need to pick one.
	  In the vast majority of cases, quoting won't be necessary,
	  so make that the default.  But, it should be possible to turn
	  it on, if needed.  If all uses of quoting are in template
	  code, this can be a #define, allowing different programs
	  built on the same system to get different quoting rules.
	  Otherwise, it will probably have to be a configure script
	  flag, which will "burn" the choice into the built binary.

	o User-settable floating-point comparison precisions?
	  Something like this: http://lists.mysql.com/plusplus/3984
	  As it currently stands, sql_cmp(double,double) is foolish.
	  One shouldn't do exact equality comparison on floating
	  point values.

	o Consider using MySQL C API enum constants in
	  mysql_type_info::types definition instead of hard-coded
	  values.  This could potentially break a lot of
	  infrastructure, though, so do it only with care.


Bug Fix/Maintenance Items
-------------------------

	These items could happen in any version.


	o 64-bit integer support has been reported to work, but more
	  confirmation is wanted.

	o Template ListInsert in lib/myset.h isn't being used within the
	  library.  It could probably be used in place of SetInsert
	  in the same file, which things like type_info.h do use now,
	  but it isn't clear how one would go about doing that without
	  changing the library code.  Document it or throw it away.

	o Update refman.css to use new Doxygen 1.4 CSS IDs.
