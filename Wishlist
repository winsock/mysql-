Patches for any of these thoughtfully considered!  See the HACKERS file
for instructions on sending patches.

Here's a meta-item that doesn't really fit into any of the categories
below: any time you must hand-roll some SQL code in your program,
consider whether it could be reduced to an API feature that would be
widely useful.  Patches or proposals of this sort are always welcome.


v3.0 Plan, For-Sure Stuff
-------------------------
    The items in this section are those things we definitely want to
    get done in v3.0.  Most of them break the ABI, so they can't wait
    for a future version, because v4 could be years out.

    o The manipulator changes sometime during 2.3 broke the column
      formatting of the examples that dump tables.  A setw(x) call
      results in x spaces, not x - strlen(whatevercamebefore).

    o Add String::compare(const char*, int), and anything else that
      looks useful from the std::string interface.

    o Try removing explicit quoting and escaping manipulators, doing it
      all implicitly upon building query strings, now that all data
      should be in STA form.  Add methods to STA to make it possible
      if at first it does not work.

    o If that works, all that should be left are the operator<<()'s,
      which can be moved into stadapter module.  Do that, and remove
      manip module and relevant userman sections.

    o Factor out quoting and escaping logic into a common function.
      Near-identical code in too many places right now.

    o Add a userman section on String and SQLTypeAdapter.

    o Replace ostream& in operator<< for STA with Query&.  At that
      point, there should be nowhere in the query string building
      process where we can't get access to the Connection object,
      so we can switch to mysql_real_escape_string() everywhere.
      This solves a longstanding problem with manipulators, which had
      to use mysql_escape_string() frequently because it didn't know
      which connection the query would be executed on.

    o Go back over mailing list thread to fold in any other changes
      suggested for RefCountedPointer.  Most especially, use
      atomic increment/decrement.  Until we do this, we don't
      yet have thread-safety.

    o Add Connection::thread_start() and thread_end(), wrapping C API.
      Mention in userman threads chapter that these only need to
      be called when doing something tricky or linking statically
      on Windows.  Automatic otherwise.

    o Add Connection::thread_safe(), wrapping mysql_thread_safe() plus
      maybe also a #defined value set at MySQL++ library build time
      if thread awareness is enabled.

    o Add multithreaded examples to test above features and the new
      ConnectionPool class?  They'd have to be platform-specific...

    o Rework elment access in subscript_iterator derivatives:

      - Change data management to work like String's new reference-
        counted buffer mechanism where possible to avoid copying
        large data blocks when returning things by value.

      - Change operator[] from value to reference semantics every
        place this is possible.

      - If we can get reference semantics everywhere, we can add
        operator->() to subscript_iterator.  It can't work with
        value semantics.

    o More robust fix for the Query stream base class init problem:
      http://www.boost.org/libs/utility/base_from_member.html

    o The quote manipulator (and presumably the others as well) don't
      work properly with char*.  See this for details:

          http://lists.mysql.com/plusplus/5617

    o Refactor option mechanism in Connection, in several steps:
    
      - Create new optionlist module, initially empty.  Each step below
        moves code and declarations into this module.

      - Replace OptionInfo struct, OptionArgType enum, and Option
        enum with a class hierarchy: totally abstract Option interface
        at the top level, BoolOption, IntOption, and StringOption at
        second level.  Each second-level class is subclassed once
        for each of the options currently defined in Options enum.
        This binds the legal option argument types with the options
        themselves, instead of requiring a lookup table to match enum
        values to types.  OptionList then becomes a list of Option*.

      - Create OptionSetter class as a base class for Connection.  It
        contains the actual option list object, provides the public
        interface to that list, and possibly a callback mechanism for
        Connection to override to give the Option objects the access
        they need to actually implement the option setting operation.
        (They need access to Connection::mysql_, for example.)

      - Add new Option subclass SSLOption, and reimplement
        Connection::enable_ssl() in terms of it.  The success of this
        will prove the value of an extensible option type system.

    o Some field_list() functions use the do_nothing manipulator,
      while others use the quote manipulator.  Need to pick one.
      In the vast majority of cases, quoting won't be necessary, so
      make that the default.  But, it should be possible to turn it
      on, if needed.  If all uses of quoting are in template code,
      this can be a #define, allowing different programs built on
      the same system to get different quoting rules.  Otherwise,
      it will probably have to be a configure script flag, which will
      "burn" the choice into the built binary.

    o Query::preview(void) should not crash when query string is
      a parsed template.  It's probably running off the end of the
      default argument list, or trying to dereference a null pointer.

    o Add user-settable floating-point comparison precisions:

        http://lists.mysql.com/plusplus/3984


v3.0 "Maybe" Stuff
------------------
    This is stuff that would be nice to have, but it wouldn't be a
    good idea to bet on seeing it in v3.0.  If you really want some
    of this, best to just get coding and provide a patch!

    o SSQLS v2:

      - Switch from C macros to a DSL that is translated to .cpp and
        .h files by a tool built along with MySQL++ library.

      - Add features to that tool to write SSQLSv2 declaration files
        from existing schemas extracted from CREATE TABLE statements,
        from running databases, and from C++ files containing old
        SSQLS v1 declarations.

      - Add table creation ability to SSQLS.  It has the schema...

      - Decouple SSQLS field order from MYSQL_ROW field order.  We can
        use field names to match up assigments, allowing you to have
        just one SSQLS definition, and have it cope no matter what
        subset of the table you query.  This will be slower than the
        current method, but SSQLS (and MySQL++ in general for that
        matter) isn't about speed.

      - Consider whether some of the current boilerplate can be
        made into a base class that all SSQLSes derive from.  Some
        template functions like Query::insert<T> might become regular
        member functions, taking a reference to the SSQLS base class.

    o Replace Query::preview() with operator<<, for easy debugging?
      If one really wants a std::string, they can still call str(),
      which is currently the same thing.

    o Define operator<< for Fields, Row, ResUse, etc.  In other
      words, there should be a way to get a user-readable version
      of received data without a lot of code.  Perhaps use a CSV
      output format, or a mysql(1) one (ASCII grid).

    o Extend the manipulators to handle nullable versions of the
      types we already support.  Should just be a matter of duplicating
      the existing type-specific manipulator functions, and wrapping
      the types in Null<>.

    o Add syntactic sugar to the Date and Time classes.  A way to
      represent SQL's NOW() function would be especially helpful.

    o Abstract all uses of MySQL C API functions into a database
      driver class with a generic interface.  This is a step towards
      database-independence, without the parallel class hierarchy
      required by the MySQL++ 1.7 design.  Also, it will make it easier
      to make class Connection completely friend-less.  Right now,
      the main reason it needs friends is because these other classes
      make C API calls using its private MYSQL data member.  The other
      reasons for it having friends aren't nearly as compelling,
      so it wouldn't be hard to justify redesigning Connection to
      eliminate these final reasons.

      While it would be easy to have just one global database
      driver object, it's probably going to be necessary to have
      one per Connection.  Consider what happens when you have one
      program connected to two very different MySQL databases, and
      you indirectly call C API functions that take MYSQL parameters.
      It's likely that those calls are supposed to behave different,
      depending on the data in that MYSQL object; for instance,
      different character encodings in the selected databases.  So,
      there must somehow be a way to pass the database driver's
      instance pointer down to all objects that will need to use
      the driver.  A side benefit is that a single program could talk
      to multiple different database server types.  Imagine a program
      for importing data from PostgreSQL and loading it into a MySQL
      table, for instance.

    o Chris Frey's packarray class

    o Figure out some way to name debug DLL and library under VC++
      differently (trailing 'd'?) to prevent some problems due
      to mixing debug and release programs and MySQL++ DLLs.
      This appears to require changes to Bakefile, or some sort of
      post-build hackery.

    o Create adaptors for std::bitset, for storing binary data in a
      MySQL table.  Make two options available, one for storing the
      return from bitset::to_ulong() in an UNSIGNED INTEGER column,
      and another for storing a larger set of bits in a more flexible
      way, perhaps as a BLOB.

    o Consider using MySQL C API enum constants in
      mysql_type_info::types definition instead of hard-coded values.
      This could potentially break a lot of infrastructure, though,
      so do it only with care.

    o Some sort of support for prepared statements.  Can we hijack
      the template query mechanism?

